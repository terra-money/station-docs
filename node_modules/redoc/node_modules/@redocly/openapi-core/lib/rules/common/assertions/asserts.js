"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asserts = exports.runOnValuesSet = exports.runOnKeysSet = void 0;
const utils_1 = require("../../../utils");
const utils_2 = require("./utils");
exports.runOnKeysSet = new Set([
    'mutuallyExclusive',
    'mutuallyRequired',
    'enum',
    'pattern',
    'minLength',
    'maxLength',
    'casing',
    'sortOrder',
    'disallowed',
    'required',
    'requireAny',
    'ref',
]);
exports.runOnValuesSet = new Set([
    'pattern',
    'enum',
    'defined',
    'undefined',
    'nonEmpty',
    'minLength',
    'maxLength',
    'casing',
    'sortOrder',
    'ref',
]);
exports.asserts = {
    pattern: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        const values = utils_1.isString(value) ? [value] : value;
        const regx = utils_2.regexFromString(condition);
        for (const _val of values) {
            if (!(regx === null || regx === void 0 ? void 0 : regx.test(_val))) {
                return { isValid: false, location: utils_1.isString(value) ? baseLocation : baseLocation.key() };
            }
        }
        return { isValid: true };
    },
    enum: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        const values = utils_1.isString(value) ? [value] : value;
        for (const _val of values) {
            if (!condition.includes(_val)) {
                return {
                    isValid: false,
                    location: utils_1.isString(value) ? baseLocation : baseLocation.child(_val).key(),
                };
            }
        }
        return { isValid: true };
    },
    defined: (value, condition = true, baseLocation) => {
        const isDefined = typeof value !== 'undefined';
        return { isValid: condition ? isDefined : !isDefined, location: baseLocation };
    },
    required: (value, keys, baseLocation) => {
        for (const requiredKey of keys) {
            if (!value.includes(requiredKey)) {
                return { isValid: false, location: baseLocation.key() };
            }
        }
        return { isValid: true };
    },
    disallowed: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        const values = utils_1.isString(value) ? [value] : value;
        for (const _val of values) {
            if (condition.includes(_val)) {
                return {
                    isValid: false,
                    location: utils_1.isString(value) ? baseLocation : baseLocation.child(_val).key(),
                };
            }
        }
        return { isValid: true };
    },
    undefined: (value, condition = true, baseLocation) => {
        const isUndefined = typeof value === 'undefined';
        return { isValid: condition ? isUndefined : !isUndefined, location: baseLocation };
    },
    nonEmpty: (value, condition = true, baseLocation) => {
        const isEmpty = typeof value === 'undefined' || value === null || value === '';
        return { isValid: condition ? !isEmpty : isEmpty, location: baseLocation };
    },
    minLength: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        return { isValid: value.length >= condition, location: baseLocation };
    },
    maxLength: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        return { isValid: value.length <= condition, location: baseLocation };
    },
    casing: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        const values = utils_1.isString(value) ? [value] : value;
        for (const _val of values) {
            let matchCase = false;
            switch (condition) {
                case 'camelCase':
                    matchCase = !!_val.match(/^[a-z][a-zA-Z0-9]+$/g);
                    break;
                case 'kebab-case':
                    matchCase = !!_val.match(/^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/g);
                    break;
                case 'snake_case':
                    matchCase = !!_val.match(/^([a-z][a-z0-9]*)(_[a-z0-9]+)*$/g);
                    break;
                case 'PascalCase':
                    matchCase = !!_val.match(/^[A-Z][a-zA-Z0-9]+$/g);
                    break;
                case 'MACRO_CASE':
                    matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(_[A-Z0-9]+)*$/g);
                    break;
                case 'COBOL-CASE':
                    matchCase = !!_val.match(/^([A-Z][A-Z0-9]*)(-[A-Z0-9]+)*$/g);
                    break;
                case 'flatcase':
                    matchCase = !!_val.match(/^[a-z][a-z0-9]+$/g);
                    break;
            }
            if (!matchCase) {
                return {
                    isValid: false,
                    location: utils_1.isString(value) ? baseLocation : baseLocation.child(_val).key(),
                };
            }
        }
        return { isValid: true };
    },
    sortOrder: (value, condition, baseLocation) => {
        if (typeof value === 'undefined')
            return { isValid: true };
        return { isValid: utils_2.isOrdered(value, condition), location: baseLocation };
    },
    mutuallyExclusive: (value, condition, baseLocation) => {
        return { isValid: utils_2.getIntersectionLength(value, condition) < 2, location: baseLocation.key() };
    },
    mutuallyRequired: (value, condition, baseLocation) => {
        return {
            isValid: utils_2.getIntersectionLength(value, condition) > 0
                ? utils_2.getIntersectionLength(value, condition) === condition.length
                : true,
            location: baseLocation.key(),
        };
    },
    requireAny: (value, condition, baseLocation) => {
        return { isValid: utils_2.getIntersectionLength(value, condition) >= 1, location: baseLocation.key() };
    },
    ref: (_value, condition, baseLocation, rawValue) => {
        if (typeof rawValue === 'undefined')
            return { isValid: true }; // property doesn't exist, no need to lint it with this assert
        const hasRef = rawValue.hasOwnProperty('$ref');
        if (typeof condition === 'boolean') {
            return {
                isValid: condition ? hasRef : !hasRef,
                location: hasRef ? baseLocation : baseLocation.key(),
            };
        }
        const regex = utils_2.regexFromString(condition);
        return {
            isValid: hasRef && (regex === null || regex === void 0 ? void 0 : regex.test(rawValue['$ref'])),
            location: hasRef ? baseLocation : baseLocation.key(),
        };
    },
};
